Mini functions:
	bool is_lowercase(int character);
	bool is_uppercase(int character);
	bool is_alphabetic(int character);
	bool is_nonalphabetic(int character);
	bool is_space(int character);
	bool is_newline(int character);

Main functions:
	void uppercase(char *buffer);
		Traverses the entire buffer, setting every character after
		a newline to uppercase, then checking every character
		afterwards if its a capital letter. If it is, then make it
		lowercase.

	void trimming(char *buffer);
		Traverses the buffer, checking for newspaces and non alphabetic 		characters. When the first of either is found, it continues
		checker if there is anything after (since there is only
		supposed to be one space and one period, comma etc).

	void silly(char *buffer, float probability);
		If it finds a letter, it calculates the probability and changes
		accordingly

	void friendly(char *buffer);
		Switches the word at the *position with the word from
		get_friendly_word, does fully since strstr returns a pointer
		to the first occurence of a substring, if they are
		consecutive. ex: If we have omusor then om, position
		will point to omusor.
	
	void rhimy(char *buffer, char *type);
		Copies the buffer into temp_buf so we can strtok it, starts
		parsing while checking if get_synonym is NULL. Enter the main
		part of the function, where depending on the type will
		traverse temp_buf2 so we can find the last letter to rhyme
		with. When it finds it, and if its different from the current
		letter, switches them (similar to friendly). Does not work if
		we need to change the second word of the pair, ex. in 1-2 3-4
		only 1 and 3 will be checked for possible switch.

